 [部分 e]

 CharCorruptionDataset 是一个生成简化的跨度损坏目标示例的类。
 请根据以下说明实现 __getitem__ 函数。
 请不要更改 __init__ 或 __getitem__ 函数的签名。

 确保实现完整规范以获得完整分数——我们在下面列出了必须满足的标准以实现完整实现。

 --------------
 掩码规范

 __getitem__ 函数接受一个索引并返回一个数据点 (x, y)，其中 x 和 y 是长度为 self.block_size 的 Long 张量。x 编码输入序列，y 编码输出序列。

 0. 使用 __getitem__ 的 idx 参数检索 self.data 中给定索引处的元素。我们将得到的数据项称为文档。

 1. 随机截断文档，使其长度不少于 4 个字符，并且不超过 int(self.block_size*7/8) 个字符。

 - 重要：您可以自由决定如何执行此随机截断，但请确保长度是随机选择的（从 4 到 int(self.block_size*7/8) 之间的每一个可能长度都有机会被选中）以获得完整分数。

 2. 现在，将（截断的）文档分成三个子字符串：

    [前缀] [被掩码的内容] [后缀]

   换句话说，选择三个字符串前缀、被掩码的内容和后缀，使得前缀 + 被掩码的内容 + 后缀 = [截断后的文档]。
   被掩码的内容的长度应是随机的，平均为截断后文档长度的 1/4。

 - 重要：您可以自由决定如何执行此操作，但请确保长度是随机选择的（有机会多于或少于截断后文档长度的 1/4）以获得完整分数。

 3. 将这些子字符串重新排列成以下形式：

     [前缀] MASK_CHAR [后缀] MASK_CHAR [被掩码的内容] [填充字符]

   这个生成的字符串，称为 masked_string，作为输出示例。
   这里 MASK_CHAR 是掩码字符，[填充字符] 是重复的 PAD_CHAR 字符串，选择这些字符使整个字符串的长度为 self.block_size + 1。
   直观地说，被掩码的内容从文档中移除并用 MASK_CHAR 替换。在字符串的后缀之后，再次出现 MASK_CHAR，后跟被移除的内容和填充字符。

 4. 现在我们使用 masked_string 构建输入和输出示例对。为此，只需将输入字符串设为 masked_string[:-1]，输出字符串设为 masked_string[1:]。换句话说，对于每个字符，目标是预测 masked_string 中的下一个字符。

 5. 利用您定义的词汇表，将生成的输入和输出字符串编码为 Long 张量并返回生成的数据点。

 ----------------
 以下是一些输入-输出对的示例 (x, y)：

   x: Khatchig Mouradian. Khatchig Mouradian is a jour⁇and tran⁇nalist, writer ⁇□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
   y: hatchig Mouradian. Khatchig Mouradian is a jour⁇and tran⁇nalist, writer ⁇□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
   x: Jaco⁇enry ⁇b H⁇□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
   y: aco⁇enry ⁇b H⁇□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
   x: John Stephen. Born in Glasgow, Steph⁇lder's apprentice on⁇en became a we⁇□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
   y: ohn Stephen. Born in Glasgow, Steph⁇lder's apprentice on⁇en became a we⁇□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□